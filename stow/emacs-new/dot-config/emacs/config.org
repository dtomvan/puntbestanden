* Hello, World!

This is a literate emacs config. It's most likely my 5th iteration of
"starting over"... I've declared bankruptcy a *LOT*.

Thanks to [[https:https://protesilaos.com/codelog/2024-11-28-basic-emacs-configuration/][protesilaos]] for the basic framework to this config. You are
truly an emacs wizard. You help us all move fast in this beast of a
lisp interpreter.

** Resources
URLs I am using, were using, or want to use for my config:
- https://github.com/lionyxml/emacs-solo
- https://protesilaos.com/emacs/dotemacs
- https://github.com/jamescherti/minimal-emacs.d
- https://protesilaos.com/codelog/2024-11-28-basic-emacs-configuration/
- https://emacswiki.org
- https://www.rahuljuliato.com/posts/dired-enhanced
- https://www.howardism.org/Technical/Emacs/journaling-org.html

* Disclaimer
This is done so that the =config.el= output file has a clear
disclaimer that this is just the output artifact and not the file to
be edited.

#+begin_src emacs-lisp
  ;;; -*- lexical-binding: t -*-
  ;;; THIS FILE IS AUTOGENERATED BY org-babel-tangle
  ;;; DO-NOT-EDIT
#+end_src

Also, to the reader of this document: *this config is very much
tailored to my own needs*. If you want to copy stuff from any config,
just copy from or use [[https:https://github.com/doomemacs/doomemacs][DOOM emacs]].

* Basic options

I use =use-package= for basically everything nowadays, in order to
structure my config. It's builtin, so I can always start my config
with a big =use-package emacs= block.

I disable a couple of builtin UI features which aren't used for a keyboard-driven workflow:
- Menu bar
- Scroll bar
- Tool bar
- Blinking cursor
- The "fringe"

I also enable the scratch buffer, for a nvim-like experience.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :init
    (global-display-line-numbers-mode 1)
    :custom
    (initial-scratch-message "")
    (initial-buffer-choice t)
    (initial-major-mode 'lisp-interaction-mode))
#+end_src

See also =early-init.el= containing some configs I stole from prot
which optimise the startup and remove general clutter.

** Custom
Put the custom file somewhere where it isn't fricking annoying.

#+begin_src emacs-lisp
  (use-package custom
    :ensure nil
    :custom
    (custom-file (locate-user-emacs-file "custom.el")))
#+end_src

** Backups
Emacs creates a bunch of =*~=-files in-place, which I do not like. It
also messes with VCS systems such as Jujutsu. Let's disable it.

#+begin_src emacs-lisp
  (setq make-backup-files nil
	backup-inhibited nil
	create-lockfiles nil)
#+end_src

** Save place
=save-place-local-mode= is used to place the point where you last left
o ff when you closed a certain file. Useful when programming or when
taking notes. Hence adding to =org-mode= and =prog-mode=.

#+begin_src emacs-lisp
  (use-package saveplace
    :ensure nil
    :hook
    (prog-mode . save-place-local-mode)
    (org-mode . save-place-local-mode))
#+end_src


** Recent files
This mode is sadly turned off by default, but it keeps track of all
recent files. Also useful to pick up where you left off last.

#+begin_src emacs-lisp
  (use-package recentf
    :ensure nil
    :init
    (recentf-mode 1))
#+end_src

** Native compilation
This snippet disables the clutter that comes with the new native
compilation of =.el= files.

#+begin_src emacs-lisp
  (when (native-comp-available-p)
    (setq native-comp-async-report-warnings-errors 'silent)
    (setq native-compile-prune-cache t))
#+end_src

** World clock
This is a wacky builtin package that displays the current time in a
number of timezones. By default it's Seattle, New York, London, Paris
and Tokyo. I'll add my local time.

#+begin_src emacs-lisp
  (use-package time
    :ensure nil ;builtin
    :init
    (with-eval-after-load 'time
      (add-to-list 'zoneinfo-style-world-list '("Europe/Amsterdam" "local"))))
#+end_src

* Packages
Eventually I want some packages installed, like evil. This requires
=package.el= and MELPA setup.

#+begin_src emacs-lisp
  (require 'package)
  (package-initialize)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
#+end_src

* UI
** Non-package
*** Theme
I've made a simple theme switcher, so that I can use Light by day and
Dark by night.

It's *almost* =toggle-theme=... I just realised

UPDATE 2025-08-25: I've added a time-of-day toggler. It will now
periodically check whether it's past seven and adjust the theme
accordingly. It's a whole minor mode and all!

#+begin_src emacs-lisp
  (use-package catppuccin-theme
    :ensure t
    :init
    (defun user/catppuccin-reload (_a)
      "reload catppuccin, except one extra argument or something"
      (interactive "i")
      (catppuccin-reload))
    (add-to-list 'after-make-frame-functions 'user/catppuccin-reload))
  (defun user/light-theme-hook ()
    "Load the light theme."
    (setq catppuccin-flavor 'latte)
    (load-theme 'catppuccin :no-confirm))
  (defun user/dark-theme-hook ()
    "Load the dark theme."
    (setq catppuccin-flavor 'mocha)
    (load-theme 'catppuccin :no-confirm))
  (defcustom user/is-dark-theme t
    "If true, use the user/dark-theme, if false, use the user/light-theme"
    :type '(boolean))
  (defun user/set-theme ()
    "Set the theme based on user/is-dark-theme."
    (interactive)
    ;; TODO: is it required to disable all other themes?
    (seq-each (lambda (theme)
		      (disable-theme theme))
		    custom-enabled-themes)
    (if user/is-dark-theme
	      (user/dark-theme-hook)
      (user/light-theme-hook)))
  (defun user/toggle-theme ()
    "Toggle the theme between light and dark."
    (interactive)
    (setq user/is-dark-theme (not user/is-dark-theme))
    (user/set-theme))

  (user/set-theme)

  (defconst user/dark-theme-max 7) ; Dark theme until 7 am
  (defconst user/dark-theme-min 19) ; Dark theme from 7 pm
  (defun user/set-theme-tod ()
    "Sets the theme based on the current time of day"
    (interactive)
    (let ((current-hour (cl-parse-integer (format-time-string "%H")))
		(old-is-dark user/is-dark-theme))
      (setq user/is-dark-theme
		  (or (>= current-hour user/dark-theme-min)
		      (<= current-hour user/dark-theme-max)))
      (when
		(not (eq old-is-dark user/is-dark-theme))
	      (user/set-theme))))

  (defvar user/theme-tod-timer nil)
  (defconst user/theme-tod-interval (* 30 60)) ; half an hour
  (define-minor-mode theme-tod-mode
    "When enabled, periodically checks for time of day and sets the theme accordingly."
    :global t
    :lighter 'theme-tod
    (when theme-tod-mode (user/set-theme-tod)) ; when toggled on do the thing initially
    (setq user/theme-tod-timer
		(if
		    (timerp user/theme-tod-timer)
		    (cancel-timer user/theme-tod-timer)
		  (run-at-time t user/theme-tod-interval 'user/set-theme-tod))))

  (theme-tod-mode 1)
#+end_src

*** Font
I use the Aporetic font, an Iosevka derivative, for my terminal, and hence
I'll set it here in the config:

I download/build the font using [[https:https://github.com/nix-community/home-manager][home-manager]] to my =~/.nix-profile=
elsewhere in my dotfiles.

#+begin_src emacs-lisp
  (set-face-attribute 'default nil :font "AporeticSansM Nerd Font" :height 130)
#+end_src

And the non-mono variant for headings, and at some pitches:

#+begin_src emacs-lisp
  (defconst user/variable-width-font "AporeticSans Nerd Font")
  (set-face-attribute 'variable-pitch nil
	:family user/variable-width-font)
  (set-face-attribute 'org-level-1 nil
	:height 1.3)
  (set-face-attribute 'org-level-2 nil
	:height 1.2)
  (set-face-attribute 'org-level-3 nil
	:height 1.1)
  (set-face-attribute 'org-level-4 nil
	:height 1.05)
#+end_src

From level 5 onwards I don't care enough anymore... it's enough
copy-paste as-is.

** With a package
*** TODO Statusline
The builtin status line for emacs is nice, but I never understand what
I'm looking at in the left corner. Skill issue?

Possible alternatives:
- https://github.com/seagle0128/doom-modeline
- https://www.emacswiki.org/emacs/powerline.el
- https://github.com/Lambda-Emacs/lambda-line
- Emacs solo modeline

*** Minibuffer
**** Vertico and marginalia
In the past I had used =smex= + =ido= for the bulk of my editing
needs, but I declare =vertico= as superior nowadays.

Marginalia adds some extra info about a search entry right next to
it. It's a no-brainer, set and forget toggle.

#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :hook (after-init . vertico-mode))
  (use-package marginalia
    :ensure t
    :hook (after-init . marginalia-mode))
#+end_src

***** C-x C-f remove path segment
To go up a directory, you can normally hit =C-DEL= until the directory
name is gone. We can do better. This tweak deletes up to the next on
=DEL= there's no filename specified, which is exactly what you need to
go up a directory...

(I thought this was builtin but I guess not?)

#+begin_src emacs-lisp
  (defun user/minibuffer-backspace ()
    "If applicable, go up to the next backslash"
    (interactive)
    (if
	  (string-match-p "/$" (minibuffer-contents))
	  (backward-kill-sexp)
      (backward-delete-char 1)))

  (with-eval-after-load 'vertico
    (bind-key (kbd "DEL") #'user/minibuffer-backspace 'vertico-map))
#+end_src

**** Orderless
Orderless is required to make searching semi-fuzzy. It allows you to
find =package-install= by writing =in pac=!

#+begin_src emacs-lisp
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

**** Consult
[[https://github.com/minad/consult][Consult]] is another minibuffer package. It is used for the following things, together with vertico and marginalia:
_ Previewing
- Grouping
- Conflating sources
- Builtin fd and ripgrep searches
- IIRC also fuzzy finding

#+begin_src emacs-lisp
  (defun consult-beframe-buffer-list (&optional frame)
    "Return the list of buffers from `beframe-buffer-names' sorted by visibility.
  With optional argument FRAME, return the list of buffers of FRAME."
    (beframe-buffer-list frame :sort #'beframe-buffer-sort-visibility))

  (use-package consult
    :after beframe
    :ensure t
    :init
    (setq consult-buffer-list-function #'consult-beframe-buffer-list)
    :bind
    ("M-s f" . consult-fd)
    ("M-s M-s" . consult-line)
    ("M-s o" . consult-outline)
    ("M-s p" . consult-ripgrep)
    ("C-x b" . consult-buffer))
#+end_src

*** Smooth scrolling
I use this functionality for touchpads on laptops. It allows to scroll
by pixel instead of by line, which on screens with a high refresh rate
makes a lot of difference. Let's actually make use of the modern
hardware we've got!

#+begin_src emacs-lisp
  (use-package ultra-scroll
    :ensure t
    :custom
    (scroll-conservatively 3)
    (scroll-margin 0)
    :config
    (ultra-scroll-mode 1))
#+end_src

*** Beframe
Another one by Prot. Allows one to integrate the builtin bookmarks and
project support to create a new frame in each context.

#+begin_src emacs-lisp
  (use-package beframe
    :ensure t
    :after evil
    :init
    (beframe-mode 1)
    (evil-global-set-key
     'normal
     (kbd "SPC b")
     'beframe-transient)
    :bind
    ("C-x b" . beframe-switch-buffer)
    ("C-x C-b" . beframe-buffer-menu)
    ("C-x f" . other-frame-prefix)
    :custom
    (beframe-functions-in-frames '(project-prompt-project-dir)))
#+end_src

* Evil mode
#+begin_src emacs-lisp
    ; required for U and C-r
    (use-package undo-tree
      :ensure t
      :init
      (setq undo-tree-history-directory-alist
	    '(("." . "~/.config/emacs/undo-tree")))
      (global-undo-tree-mode 1))

    (setq evil-undo-system 'undo-tree
	    evil-want-keybinding nil
	    evil-want-C-u-scroll t)

    ; required for certain functionality I can't remember
    (use-package goto-chg
      :ensure t)

    (defun user/evil-insert-paste ()
      (interactive)
      (evil-paste-from-register ?\"))

    (use-package evil
      :ensure t
      :init
      (evil-mode 1)
      :bind
      (:map evil-insert-state-map
		    ("C-y" . user/evil-insert-paste))	; paste with emacs keybind even in insert mode
      )
#+end_src

** Keymaps
Above in [[Theme]] I couldn't set the keymap set because evil wasn't loaded yet. Now it is...

#+begin_src emacs-lisp
  (evil-global-set-key
   'normal
   (kbd "SPC t h")
   'user/toggle-theme)
#+end_src

** Relative line numbers
I've grouped this one under evil mode, because relative line numbers
are really useful in vim motions and not so much in the default Emacs
editing scheme.

#+begin_src emacs-lisp
  (setq display-line-numbers-type 'relative)
#+end_src

** Evil collection
Various supplemental packages that:
- Backport existing (mostly tpope's) vim plugins to emacs
- Add vim support to major modes, like dired's

#+begin_src emacs-lisp
  (use-package evil-commentary
    :ensure t
    :after evil
    :init (evil-commentary-mode))

  (use-package evil-surround
    :ensure t
    :after evil
    :config
    (global-evil-surround-mode 1))

  (use-package evil-collection
    :ensure t
    :after evil
    :init
    (evil-collection-init))
#+end_src

*** Binding to the =config.org= file
#+begin_src emacs-lisp
  (defun user/open-config ()
    "open the config file"
    (interactive)
    (find-file (locate-user-emacs-file "config.org")))

  (evil-global-set-key
   'normal
   (kbd "SPC c f")
   'user/open-config)
#+end_src


*** =:*new= command fix
I also want =*new*= buffers to be launched into =lisp-interaction-mode=.

#+begin_src emacs-lisp
  (defun user/evil-buffer-new (_a)
    "open `lisp-interaction-mode' in a new empty buffer"
    (interactive "i")
    (let ((buffer (generate-new-buffer "*new*")))
      (with-current-buffer buffer (lisp-interaction-mode))
      (set-window-buffer nil buffer)))

  (advice-add 'evil-buffer-new :override #'user/evil-buffer-new)
#+end_src

**** TODO can I do this with an =:after= advice???

* History
The builtin =savehist.el= allows you to save =M-x= (and others')
history to a file in =.emacs.d=.

#+begin_src emacs-lisp
  (use-package savehist
    :ensure nil
    :hook (after-init . savehist-mode))
#+end_src

* Editor tomfoolery
This chapter is about niceties that one wants to see in a modern text
editor, like autocomplete and autopairs.
** Editorconfig support
Emacs has builtin editorconfig support. Let's enable it:
#+begin_src emacs-lisp
  (use-package editorconfig
    :ensure nil
    :custom
    ;; otherwise the dir-locals system will yell at you that you are
    ;; trying to use unsafe variables even tho it's just editorconfig.
    ;; the editorconfig system is kind-of messed up in emacs.
    ;; See https://cgit.git.savannah.gnu.org/cgit/emacs.git/tree/lisp/editorconfig.el?h=emacs-30.2
    (enable-local-variables :safe)
    :init
    (editorconfig-mode t))
#+end_src
** Direnv support
Not much to say. It's used to make my devshell work in eshell. Among
other things like =compilation-mode=.

#+begin_src emacs-lisp
  (use-package envrc
    :ensure t
    :hook (after-init . envrc-global-mode))
#+end_src

** Simple autocomplete
I am planning to keep using NVim for writing code, with an extensive
=nixvim= framework for declarative nvim configs. This way I can have a
simple LSP setup without much hassle. It's basically
=plugins.lspconfig.enable = true;=...

Also this snippet is stolen from Prot 1:1.

Sadly only autocompletes in an actual emacs-lisp file and not within an emacs-lisp source block in org...

Hopefully useful for writing notes.

#+begin_src emacs-lisp
  (use-package corfu
  :ensure t
  :hook (after-init . global-corfu-mode)
  :bind (:map corfu-map ("<tab>" . corfu-complete))
  :config
  (setq tab-always-indent 'complete)
  (setq corfu-preview-current nil)
  (setq corfu-min-width 20)

  (setq corfu-popupinfo-delay '(1.25 . 0.5))
  (corfu-popupinfo-mode 1) ; shows documentation after `corfu-popupinfo-delay'

  ;; Sort by input history (no need to modify `corfu-sort-function').
  (with-eval-after-load 'savehist
    (corfu-history-mode 1)
    (add-to-list 'savehist-additional-variables 'corfu-history)))
#+end_src

** Whitespace
A builtin nicety, should be on by default IMO. Comparable to nvim's
=*editorconfig.trim_trailing_whitespace*=.

#+begin_src emacs-lisp
  (use-package whitespace
    :ensure nil
    :defer t
    :hook (before-save . whitespace-cleanup))
#+end_src

** TODO Autopairs
This is a bit janky at the moment, hence the TODO. It's free real
estate though, it's builtin autopairs!

#+begin_src emacs-lisp
  (use-package elec-pair
    :ensure nil
    :defer
    :hook (prog-mode . electric-pair-local-mode))

  (use-package paren
    :ensure nil
    :hook (after-init . show-paren-mode)
    :custom
    (show-paren-delay 0)
    (show-paren-style 'mixed)
    (show-paren-context-when-offscreen t))
#+end_src

* Projects
Emacs has builtin Git and project support, let's use it. I'll remap =SPC p= to =C-x p=, to make my setup more vimmy.

#+begin_src emacs-lisp
  (use-package project
    :ensure nil
    :config
    (add-to-list 'project-vc-extra-root-markers ".jj"))

  (evil-global-set-key 'normal (kbd "SPC p") project-prefix-map)
#+end_src

** Jujutsu support
Magit and =vc-mode= already have good support for Git, but not for
jujutsu. Let's use the experimental =vc-jj= for that...

#+begin_src emacs-lisp
  (use-package vc-jj
    :after project
    :ensure t
    :config
    (add-to-list 'project-vc-backend-markers-alist '(jj . ".jj")))
#+end_src

* Filetypes
** Org mode!!!
This is the most important part: setting up org mode. It mostly speaks
for itself, and the config knows what it is.

If you get that reference you've watched too much American reality TV.

#+begin_src emacs-lisp
  (defvar user/org-root "~/org/refile.org" "The file to open orgmode in initially.")
  (defun user/org-open ()
    "Open orgmode file at which my vault starts."
    (interactive)
    (find-file (expand-file-name user/org-root)))

  (use-package org
    :ensure nil
    :init
    (global-set-key (kbd "C-c l") 'org-store-link)
    (global-set-key (kbd "C-c a") 'org-agenda)
    (global-set-key (kbd "C-c b") 'user/org-open)
    (global-set-key (kbd "C-c c") 'org-capture)
    :custom
    (org-directory "~/org")
    (org-default-notes-file "~/org/refile.org")
    (org-agenda-files '("~/org"))
    (org-log-done 'time) ; log the datetime when you marked a todo as done
    (org-log-refile 'time) ; log the datetime when you refiled something

    (org-agenda-custom-commands
      '(("u" "Unscheduled TODOs"
	 tags "+TODO=\"TODO\"-SCHEDULED={}")))

    ;; When exporting to .ical, do the right thing and use due dates
    ;; as event dates
    ;; Otherwise, one has to specify a property to do icalendar stuff,
    ;; which isn't a sensible default IMO
    (org-icalendar-use-deadline '(even-if-todo-not-done))
    (org-icalendar-use-scheduled '(even-if-todo-not-done))

    (org-log-into-drawer t)
    (org-use-fast-todo-selection t)
    (org-treat-S-cursor-todo-selection-as-state-change nil))

  (use-package evil-org
    :ensure t
    :after org
    :hook (org-mode . (lambda () evil-org-mode))
    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
#+end_src

*** Org capture
Seperate section for clarity and searchability.

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-capture-templates
	    '(("t" "todo" entry (file "") "\n* TODO %?\n%U\n%a\n")
	      ;; ("n" "note" entry (file "") "\n* %? :NOTE:\n%U\n%a\n")
	      ("r" "reading list" item (file+olp "" "Reading list" "Uncategorized"))
	      ("c" "config entry"
	       entry (file "~/.config/emacs/config.org")
	       "* %?\n\n#+begin_src emacs-lisp\n\n#+end_src\n")
	      ;; OBTF for daily, no YYYY-MM-dd.md anymore
	      ("j" "Journal Entry"
	       entry (file+olp+datetree "~/org/daily.org")
	       "* %?"
	       :empty-lines 1))))
#+end_src

*** Org clipper
Defines a command =user/org-get-clipper=, which copies a command to
the clipboard to paste into the devtools console, in order to obtain a
link with the title to paste into an org document.

Workflow:
1. Call the command
2. Paste into devtools
3. Paste into note

Or is this builtin already in some way?

#+begin_src emacs-lisp
  (defconst user/org-clipper-value "copy(`[[${location.href}][${document.title}]]`)")
  (defun user/org-get-clipper ()
    (interactive)
    (kill-new user/org-clipper-value))
#+end_src

*** TODO Org refile
Target files specified as central places that refiles can go. I am not
sure yet what I'll use this for, but I'll add =refile.org= and
=projects.org= to the list...

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-refile-targets
	  '(
	    ("~/org/refile.org" . (:level . 2))
	    ("~/org/projects.org" . (:level . 1))
	    (nil . (:level . 1))
	    )))
#+end_src

** Markdown support
Uses Prot's amazing =Denote= to "do zettelkasten".

#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t)
  (defun user/denote-dired ()
    "dired at the denote root directory"
    (interactive)
    (dired org-directory))
  (use-package denote
    :ensure t
    :after dired
    :custom
    (denote-directory org-directory)
    (denote-file-type "markdown-yaml") ;like obsidian
    :bind
    (:map evil-normal-state-map
				("SPC d d" . user/denote-dired)
				("SPC d n" . denote)
				("SPC d N" . denote-type)
				("SPC d l" . denote-link)
				("SPC d r" . denote-rename-file))
    :hook
    ((dired-mode . denote-dired-mode))
    )

  ;; Allows you to convert Obsidian to Denote links and back, etc.
  ;; TODO: maybe customize `denote-md-link-format'?
  (use-package denote-markdown
    :ensure t
    :after denote)

  (use-package consult-denote
    :ensure t
    :bind
    (:map evil-normal-state-map
	  ("SPC d f" . consult-denote-find)
	  ("SPC d p" . consult-denote-grep))
    :config
    (consult-denote-mode 1))
#+end_src

** Typst support

I use =typst-ts-mode=.

#+begin_src emacs-lisp
  ;; TODO: remove if confirmed that it's useless given that I install it through nix
  ;; (with-eval-after-load 'treesit
  ;;   (unless (treesit-language-available-p 'typst)
  ;;     (add-to-list 'treesit-language-source-alist
  ;;	   '(typst "https://github.com/uben0/tree-sitter-typst"))
  ;;     (treesit-install-language-grammar 'typst)))
  (use-package typst-ts-mode
    :ensure t)
#+end_src

* Git support
#+begin_src emacs-lisp
  (use-package vc
    :ensure nil
    :custom
    (vc-follow-symlinks t))
  (use-package magit
    :commands (magit)
    :ensure t)
#+end_src

* Dired

This snippet hides dotfiles by default and allows me to show them on
=C-S-.=!
#+begin_src emacs-lisp
  (with-eval-after-load 'dired
    (require 'dired-x)
    (add-hook 'dired-mode-hook 'dired-omit-mode)
    (setq dired-omit-files
	     (concat dired-omit-files "\\|^\\."))
    (bind-key (kbd "C->") #'dired-omit-mode 'dired-mode-map))
#+end_src

This snippet groups directories first and enables human-readable
sizes, something which should be the default IMO.

#+begin_src emacs-lisp
  (setq dired-use-ls-dired t
	dired-listing-switches "-lah  --group-directories-first")
#+end_src

This snippet makes sure you don't leave behind a big trail of dired
buffers everytime you cd. The manual is very clear:

#+begin_quote
If non-nil, kill the current buffer when selecting a new directory.
#+end_quote

#+begin_src emacs-lisp
  (setq dired-kill-when-opening-new-dired-buffer t)
#+end_src

* DWIM
** Dired DWIM
Also by Prot.
#+begin_src emacs-lisp
  (use-package dired
    :ensure nil
    :commands (dired)
    :hook
    ((dired-mode . dired-hide-details-mode)
     (dired-mode . hl-line-mode))
    :config
    (setq dired-recursive-copies 'always)
    (setq dired-recursive-deletes 'always)
    (setq delete-by-moving-to-trash t)
    (setq dired-dwim-target t))
#+end_src

** C-g DWIM
Also by Prot.

#+begin_src emacs-lisp
    (defun prot/keyboard-quit-dwim ()
    "Do-What-I-Mean behaviour for a general `keyboard-quit'.

  The generic `keyboard-quit' does not do the expected thing when
  the minibuffer is open.  Whereas we want it to close the
  minibuffer, even without explicitly focusing it.

  The DWIM behaviour of this command is as follows:

  - When the region is active, disable it.
  - When a minibuffer is open, but not focused, close the minibuffer.
  - When the Completions buffer is selected, close it.
  - In every other case use the regular `keyboard-quit'."
    (interactive)
    (cond
     ((region-active-p)
      (keyboard-quit))
     ((derived-mode-p 'completion-list-mode)
      (delete-completion-window))
     ((> (minibuffer-depth) 0)
      (abort-recursive-edit))
     (t
      (keyboard-quit))))

  (define-key global-map (kbd "C-g") #'prot/keyboard-quit-dwim)
#+end_src

* TODO Programming
I am intending to use this Emacs config just for writing notes for the
time being, but since Emacs is an operating system I might as well
start trying to convert it to my IDE as well. I just don't like the
heaviness of the builtin eglot so much...

** Tree-sitter
[[https://github.com/tree-sitter/tree-sitter][Tree-sitter]] is a framework for performant AST parsing, generated from
a single =.js= file containing a grammar. It is used in LSP's to
"understand" the code, but it's also used for syntax highlighting in
editors. It's generally much more correct and thorough than the legacy
regexp-based =*-mode= packages, so I'll be using that.

#+begin_src emacs-lisp
  (use-package tree-sitter-langs
    :ensure t)
#+end_src

** Nix
For some reason, the =emacs-tree-sitter/treesit-langs= bundle doesn't include the nix parser, so I'll fallback to =nix-mode=:

#+begin_src emacs-lisp
  (use-package nix-mode
    :ensure t)
#+end_src

** TODO LSP
How do I do LSP support? Or am I finally turning into a 10x developer
gigachad that remembers all APIs by heart and never makes any
mistakes?

To be fair, you can get pretty far with =M-x compile= if the compiler
you are using returns a proper format for a file location, like
=filename.ext:121:7=.

There's a lot of ways:
- lsp-mode
- eglot
- flycheck
- [[https://github.com/manateelazycat/lsp-bridge][LSP-bridge]]

Supplementals such as:
- xref
- eldoc
- company

Installing LSPs (I am on NixOS so there's a lotta ways...):
- =nix-shell=
- NixOS
- Home-Manager
- =nix profile install=
- Distrobox?? But then I'd need to run Emacs itself from a distrobox
  also (which is possible with the =emacs-wayland= package, which also
  has PGTK and native-comp)
- Linuxbrew??? Does that even work on nixos?

** TODO yasnippet
I want to use yasnippet at some point, but not now, I want to focus on
the note-taking part of Emacs.

But I'll write this down: I want to be able to import
[[https:https://github.com/rafamadriz/friendly-snippets/][friendly-snippets]] into my Emacs to make it worth my while.

* RSS
For RSS reading, the one and only Elfeed seems to be a great
option. Let's install it into our OS.

#+begin_src emacs-lisp
  (use-package elfeed
    :ensure t
    :bind
    (:map evil-normal-state-map
	  ("SPC r s s" . elfeed)))

  (use-package elfeed-org
    :ensure t
    :after elfeed
    :init
    (elfeed-org)
    :custom
    (rmh-elfeed-org-files (list "~/.config/emacs/elfeed.org")))
#+end_src

* EAT - Emulate A Terminal
It's to integrate everything nicely and to actually be able to run
TUI's and other weird terminal stuff inside of eshell.

#+begin_src emacs-lisp
  (use-package eat
    :ensure t
    :hook
    (eshell-load . eat-eshell-mode))
#+end_src
